# SPDX-License-Identifier: BSD-3-Clause

from request import Request

class Referrer(object):
    '''Represents an entity that can generate requests.
    Examples of Referrers are hyperlinks, which generate one fixed request, and
    forms, which generate many requests.
    '''
    method = 'get'

    def __init__(self, pageURL):
        self.pageURL = pageURL

    def hasRequest(self, request):
        '''Returns True iff this referrer could generate the given request.
        Note that it is possible for hasRequest() to return True even though
        the request in question is not generated by iterRequests().
        '''
        raise NotImplementedError

    def iterRequests(self):
        '''Iterates through requests generated by this referrer.
        Preferably, the requests should be returned in an order such that
        there is a lot of variation between subsequent requests. This improves
        the test coverage when we only have time to try the first N requests.
        The iteration is not expected to return every possible request that
        can be generated by this referrer, just a number of interesting ones.
        Note that free inputs such as text fields have an infinite value set,
        so it would not even be possible to generate everything.
        '''
        raise NotImplementedError

class Redirect(Referrer):

    def __init__(self, request):
        Referrer.__init__(self, request.pageURL)
        self.target = request

    def hasRequest(self, request):
        return request == self.target

    def iterRequests(self):
        yield self.target

class LinkSet(Referrer):

    def __init__(self):
        Referrer.__init__(self, None) # pageURL is set later
        self.links = set()

    def add(self, request):
        if self.pageURL is None:
            self.pageURL = request.pageURL
        else:
            assert self.pageURL == request.pageURL
        self.links.add(request)

    def hasRequest(self, request):
        return request in self.links

    def iterRequests(self):
        return iter(self.links)

class Form(Referrer):

    def __init__(self, pageURL, method, controls):
        assert method in ('get', 'post')
        Referrer.__init__(self, pageURL)
        self.method = method
        self.controls = controls

        # Gather all alternatives in a single data structure.
        # TODO: We could improve the chances of submitting valid free input by
        #       looking at what other pages fill in and the default value.
        #       For example, if we see numbers being filled in, it could be
        #       a numeric field. This feature would require the set of
        #       alternatives to change as we gather more hints about the
        #       control.
        self.allAlternatives = allAlternatives = []
        self.baseQuery = baseQuery = []
        combinations = 1
        for control in controls:
            # Filter out duplicates.
            alternatives = set(
                (None, None) if name is None or value is None
                else (name, value)
                for name, value in control.alternatives()
                )
            if len(alternatives) == 1:
                # If there is only once choice, make that choice now.
                name, value = alternatives.pop()
                if name is not None and value is not None:
                    baseQuery.append((name, value))
            elif alternatives:
                # Store possible choices.
                allAlternatives.append(tuple(alternatives))
                combinations *= len(alternatives)

        self.combinations = combinations

        print 'non-alternatives:', baseQuery
        print 'alternatives:', allAlternatives
        print 'combinations:', combinations

    def hasRequest(self, request):
        # Check if page matches.
        if self.pageURL != request.pageURL:
            return False

        # We can never produce more pairs than we have controls.
        if len(request.query) > len(self.controls):
            return False

        # Create a matrix of bools that stores which control and pair
        # combinations are possible.
        producesPairs = [
            [control.hasAlternative(name, value)
             for name, value in request.query]
            for control in self.controls
            ]
        # Store which controls can be omitted from the submission.
        producesEmpty = [
            control.hasAlternative(None, None)
            for control in self.controls
            ]

        class MatrixIterator(object):
            '''Base class for ControlIterator and PairIterator.
            '''
            def __init__(self):
                self._index = self._getLength()
                self._changed = False
            def __iter__(self):
                return self
            def _getLength(self):
                raise NotImplementedError
            def _valueAt(self, index):
                raise NotImplementedError
            def isChanged(self):
                return self._changed
            def removeControl(self, controlIndex):
                del producesPairs[controlIndex]
                del producesEmpty[controlIndex]
                self._changed = True
            def removePair(self, pairIndex):
                for produced in producesPairs:
                    del produced[pairIndex]
                self._changed = True
            def next(self):
                index = self._index
                if index == 0:
                    raise StopIteration
                index -= 1
                self._index = index
                return self._valueAt(index)

        class ControlIterator(MatrixIterator):
            '''Iterates through producesPairs and producesEmpty one control
            at a time, offering methods to remove controls and pairs without
            disturbing the iteration in progress.
            '''
            def removeControl(self): # pylint: disable=arguments-differ
                MatrixIterator.removeControl(self, self._index)
            def _getLength(self):
                return len(producesPairs)
            def _valueAt(self, index):
                return producesPairs[index], producesEmpty[index]

        class PairIterator(MatrixIterator):
            '''Iterates through producesPairs one pair at a time, offering
            methods to remove controls and pairs without disturbing the
            iteration in progress.
            '''
            def removePair(self): # pylint: disable=arguments-differ
                MatrixIterator.removePair(self, self._index)
            def _getLength(self):
                return len(producesPairs[0]) if producesPairs else 0
            def _valueAt(self, index):
                return [
                    controlIndex
                    for controlIndex, produces in enumerate(producesPairs)
                    if produces[index]
                    ]

        # Simplify the matrix as much as possible.
        # We go through a lot of trouble to minimize the size of the matrix,
        # since the generic solver has an exponential run time.
        while True:
            # Check whether each control can produce something that matches the
            # request query.
            controlIt = ControlIterator()
            for produced, empty in controlIt:
                numPairs = produced.count(True)
                if numPairs == 0:
                    # None of the pairs this control can produce are part of
                    # the request...
                    if empty:
                        # ...but it can produce nothing.
                        controlIt.removeControl()
                    else:
                        # ...and it must produce something.
                        return False
                elif numPairs == 1 and not empty:
                    # Exactly one pair that this control can produce is part of
                    # the request and it must produce something.
                    controlIt.removeControl()
                    controlIt.removePair(produced.index(True))

            # We can never produce more pairs than we have controls.
            # Check again now that the list of controls is possibly shorter.
            if producesPairs and len(producesPairs[0]) > len(producesPairs):
                return False

            # Resolve request pairs that can only be produced by a single
            # control.
            pairIt = PairIterator()
            for producers in pairIt:
                numControls = len(producers)
                if numControls == 0:
                    # No control can produce this name-value pair.
                    return False
                elif numControls == 1:
                    # Exactly one control can produce this name-value pair.
                    pairIt.removeControl(producers[0])
                    pairIt.removePair()

            if not (controlIt.isChanged() or pairIt.isChanged()):
                # No more simplifications possible.
                break

        # For most forms, there will be nothing left after eliminating the
        # simple cases, because the control names do not overlap.
        if len(producesPairs) == 0:
            return True

        # Recursively try to find a solution.
        # We don't have to know the solution, only check its existence.
        remainingPairs = range(len(producesPairs[0]))
        def solveRec(controlIndex):
            if controlIndex == len(producesPairs):
                return True
            produced = producesPairs[controlIndex]
            # Note that remainingPairs contains the same elements (not
            # necessarily in the same order) when this function returns
            # False; if it returns True then the contents of remainingPairs
            # don't matter anymore.
            pairIndex = remainingPairs.pop()
            switchIndex = 0
            while True:
                if produced[pairIndex]:
                    if solveRec(controlIndex + 1):
                        return True
                if switchIndex == len(remainingPairs):
                    break
                remainingPairs[switchIndex], pairIndex = \
                    pairIndex, remainingPairs[switchIndex]
                switchIndex += 1
            remainingPairs.append(pairIndex)
            return False
        return solveRec(0)

    def iterRequests(self):
        progress = 0
        # TODO: Design an algorithm to compute a good increment.
        increment = 83
        while True:
            index = progress
            query = []
            for alternatives in self.allAlternatives:
                index, choice = divmod(index, len(alternatives))
                alternative = alternatives[choice]
                if alternative[0] is not None:
                    query.append(alternative)
            yield Request(self.pageURL, self.baseQuery + query, maybeBad=True)
            progress = (progress + increment) % self.combinations
            if progress == 0:
                # Because increment and combinations are relatively prime,
                # reaching 0 means we've visited all indices.
                break
